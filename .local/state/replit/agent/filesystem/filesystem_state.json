{"file_contents":{"Account.swift":{"content":"\nimport Foundation  \n\n\nclass Account: Reportable {\n    let name: String\n    var balance: Double\n    var transactions: [Transaction]\n\n    init(name: String, initialBalance: Double) {\n        self.name = name\n        self.balance = initialBalance\n        self.transactions = []\n    }\n\n    func addTransaction(description: String, amount: Double, type: TransactionType) {\n        let transaction = Transaction(description: description, amount: amount, type: type)\n        transactions.append(transaction)\n        if type == .income {\n            balance += amount\n        } else {\n            balance -= amount\n        }\n    }\n\n    func displayDetails() -> String {\n        return \"Account: \\(name) | Balance: $\\(String(format: \".2f\", balance))\"\n    }\n\n    func generateReport() -> String {\n        var report = \"--- Report for \\(name) ---\\n\"\n        report += displayDetails() + \"\\n\"\n        report += \"--- Transactions ---\\n\"\n        if transactions.isEmpty {\n            report += \"No transactions.\\n\"\n        } else {\n            for transaction in transactions {\n                report += transaction.generateReport() + \"\\n\"\n            }\n        }\n        return report\n    }\n}\n\nclass CheckingAccount: Account {\n    override func displayDetails() -> String {\n        return \"Checking Account: \\(name) | Balance: $\\(String(format: \".2f\", balance))\"\n    }\n}\n\nclass SavingsAccount: Account {\n    let interestRate: Double\n\n    init(name: String, initialBalance: Double, interestRate: Double) {\n        self.interestRate = interestRate\n        super.init(name: name, initialBalance: initialBalance)\n    }\n\n    func applyInterest() {\n        let interestAmount = balance * interestRate\n        addTransaction(description: \"Interest Applied\", amount: interestAmount, type: .income)\n        print(\"Applied $\\(String(format: \".2f\", interestAmount)) interest to \\(name).\")\n    }\n\n    override func displayDetails() -> String {\n        let ratePercent = String(format: \".2f\", interestRate * 100)\n        return \"Savings Account: \\(name) | Balance: $\\(String(format: \".2f\", balance)) | Interest Rate: \\(ratePercent)%\"\n    }\n}\n\n","size_bytes":2118},"ReportGenerator.swift":{"content":"\n\n//\n//  ReportGenerator.swift\n//\n\nimport Foundation\n\n//  This file provides a service for generating reports.\nstruct ReportGenerator {\n\n\n    static func generateMasterReport(from items: [Reportable]) -> String {\n        var masterReport = \"\" \n\n        masterReport += \"========== MASTER REPORT ==========\\n\\n\"\n\n        for item in items {\n            masterReport += item.generateReport()\n            masterReport += \"\\n------------------------------------\\n\\n\"\n        }\n\n        masterReport += \"======== END OF MASTER REPORT ========\"\n\n        return masterReport\n    }\n}\n\n","size_bytes":577},"Transaction.swift":{"content":"\n//\n//  Transaction.swift\n//\n\nimport Foundation\n\n\nstruct Transaction: Identifiable, Equatable, Reportable {\n    let id: UUID\n    let date: Date\n    let description: String\n    let amount: Double\n    let type: TransactionType\n\n    var isExpense: Bool {\n        return type == TransactionType.expense\n    }\n\n    init(id: UUID = UUID(), date: Date = Date(), description: String, amount: Double, type: TransactionType) {\n        self.id = id\n        self.date = date\n        self.description = description\n        self.amount = amount\n        self.type = type\n    }\n\n    static func == (lhs: Transaction, rhs: Transaction) -> Bool {\n        return lhs.id == rhs.id\n    }\n\n    func generateReport() -> String {\n        let formatter = DateFormatter()\n        formatter.dateStyle = .short\n        let formattedDate = formatter.string(from: date)\n        return \"On \\(formattedDate), \\(description) (\\(type.rawValue)): $\\(String(format: \"%.2f\", amount))\"\n    }\n}\n","size_bytes":956},"TransactionType.swift":{"content":"\n//\n//  TransactionType.swift\n//\n\nimport Foundation\n\n// This enum represents the type of a transaction, either income or expense.\nenum TransactionType: String {\n    case income = \"Income\"\n    case expense = \"Expense\"\n}\n\n","size_bytes":220},"main.swift":{"content":"\n\n//\n//  main.swift\n//\n\nimport Foundation\n\nclass FinanceApp {\n    // 'accounts' is a variable array because we might add/remove accounts in the future.\n    private var accounts: [Account] = []\n    private var shouldQuit = false\n\n    // 1. SETUP\n    func setupSampleData() {\n        print(\"Setting up sample accounts...\")\n        // Use 'let' for constants that won't change after creation.\n        let checking = CheckingAccount(name: \"Main Checking\", initialBalance: 1500.00)\n        let savings = SavingsAccount(name: \"Vacation Fund\", initialBalance: 500.00, interestRate: 0.02)\n\n        // Add some transactions\n        checking.addTransaction(description: \"Paycheck\", amount: 2200.00, type: .income)\n        checking.addTransaction(description: \"Groceries\", amount: 150.75, type: .expense)\n        checking.addTransaction(description: \"Rent\", amount: 1200.00, type: .expense)\n\n        savings.addTransaction(description: \"Initial Deposit\", amount: 500.00, type: .income)\n        savings.addTransaction(description: \"Concert Tickets\", amount: 250.00, type: .expense)\n\n        // Apply interest to the savings account\n        savings.applyInterest()\n\n        accounts = [checking, savings]\n        print(\"Sample data created.\\n\")\n    }\n\n    // 2. MAIN APP LOOP\n    func run() {\n        setupSampleData()\n\n        while !shouldQuit {\n            printMenu()\n            handleUserInput()\n        }\n    }\n\n    // Fulfills Requirement: Functions (with no parameters or return)\n    func printMenu() {\n        print(\"====================================\")\n        print(\"What would you like to do?\")\n        print(\"1. List all accounts\")\n        print(\"2. View details for an account\")\n        print(\"3. Generate master report\")\n        print(\"4. Exit\")\n        print(\"====================================\")\n        print(\"Enter your choice:\", terminator: \" \")\n    }\n\n    // Fulfills Requirement: Functions & Control Flow (switch)\n    func handleUserInput() {\n        // Fulfills Requirement: Optionals Handling (if let)\n        if let choice = readLine() {\n            print(\"\\n\") // Add a newline for better formatting\n            switch choice {\n            case \"1\":\n                listAllAccounts()\n            case \"2\":\n                viewAccountDetails()\n            case \"3\":\n                generateMasterReport()\n            case \"4\":\n                shouldQuit = true\n                print(\"Thank you for using the Personal Finance App!\")\n            default:\n                print(\"Invalid choice. Please try again.\")\n            }\n        } else {\n            print(\"\\nCould not read input. Please try again.\")\n        }\n        print(\"\\n\") // Add spacing before the next menu\n    }\n\n    // 3. MENU ACTIONS\n\n    func listAllAccounts() {\n        print(\"--- Your Accounts ---\")\n        for account in accounts {\n            // Here we call the overridden method for each account type\n            print(account.displayDetails())\n        }\n        print(\"---------------------\")\n    }\n\n    // Fulfills Requirement: Optionals Handling (guard let)\n    func viewAccountDetails() {\n        print(\"Enter the name of the account to view:\", terminator: \" \")\n        guard let name = readLine(), !name.isEmpty else {\n            print(\"Invalid name. Returning to menu.\")\n            return\n        }\n\n        // Fulfills Requirement: Functions (returning an optional)\n        if let account = findAccount(byName: name) {\n            print(account.generateReport())\n        } else {\n            print(\"Account with name '\\(name)' not found.\")\n        }\n    }\n\n    func generateMasterReport() {\n        print(\"Generating master report for all accounts...\")\n        // Here we use our ReportGenerator service with our array of accounts.\n        // This works because 'Account' conforms to the 'Reportable' protocol.\n        let report = ReportGenerator.generateMasterReport(from: accounts)\n        print(report)\n    }\n\n    // 4. HELPER FUNCTIONS\n\n    // Fulfills Requirement: Functions (with parameters and optional return)\n    func findAccount(byName name: String) -> Account? {\n        // Find the first account where the name matches (case-insensitively)\n        return accounts.first { $0.name.lowercased() == name.lowercased() }\n    }\n}\n\n// 5. START THE APP\nlet app = FinanceApp()\napp.run()\n\n","size_bytes":4294},"Reportable.swift":{"content":"\n//\n//  Reportable.swift\n//\n\nimport Foundation\n\n//this file defines a protocol named 'Reportable' with a single method 'generateReport()' that returns a string. and any cinforming type can generate a report string.\nprotocol Reportable {\n    func generateReport() -> String\n}\n","size_bytes":275}},"version":1}